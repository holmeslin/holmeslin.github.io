<!doctype html><html lang=zh-tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Go 語言 sync 包的應用詳解 - Feng-Chi&#39;s Note-Take</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content=Feng-Chi><meta name=description content="並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 goroutine 在訪問同一片內存時不會出現混亂的問題。
Go 語言的 sync 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 sync 包裡這些同步的應用場景 ， 同時也會介紹 sync 包中的 Pool 和 Map 的應用場景和使用方法。"><meta name=keywords content=blog,note,note-take><meta name=generator content="Hugo 0.57.2 with theme even"><link rel=canonical href=https://holmeslin.github.io/post/2020/07/go-sync/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.6eb09ed45a88bd339269c14515d2a11f2e0afdadbdd763d83f9b5c797166b081.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property=og:title content="Go 語言 sync 包的應用詳解"><meta property=og:description content="並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 goroutine 在訪問同一片內存時不會出現混亂的問題。

Go 語言的 sync 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 sync 包裡這些同步的應用場景 ， 同時也會介紹 sync 包中的 Pool 和 Map 的應用場景和使用方法。"><meta property=og:type content=article><meta property=og:url content=https://holmeslin.github.io/post/2020/07/go-sync/><meta property=og:image content=https://holmeslin.github.io><meta property=article:published_time content=2020-07-07T15:07:16+08:00><meta property=article:modified_time content=2020-07-07T15:07:16+08:00><meta itemprop=name content="Go 語言 sync 包的應用詳解"><meta itemprop=description content="並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 goroutine 在訪問同一片內存時不會出現混亂的問題。

Go 語言的 sync 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 sync 包裡這些同步的應用場景 ， 同時也會介紹 sync 包中的 Pool 和 Map 的應用場景和使用方法。"><meta itemprop=datePublished content=2020-07-07T15:07:16&#43;08:00><meta itemprop=dateModified content=2020-07-07T15:07:16&#43;08:00><meta itemprop=wordCount content=2741><meta itemprop=image content=https://holmeslin.github.io><meta itemprop=keywords content=golang,><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://holmeslin.github.io><meta name=twitter:title content="Go 語言 sync 包的應用詳解"><meta name=twitter:description content="並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 goroutine 在訪問同一片內存時不會出現混亂的問題。

Go 語言的 sync 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 sync 包裡這些同步的應用場景 ， 同時也會介紹 sync 包中的 Pool 和 Map 的應用場景和使用方法。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Feng-Chi</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>Feng-Chi</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Go 語言 sync 包的應用詳解</h1><div class=post-meta><span class=post-time>2020-07-07</span><div class=post-category><a href=/categories/%E7%B4%80%E9%8C%84/>紀錄</a>
<a href=/categories/%E5%AD%B8%E7%BF%92/>“學習”</a></div></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目錄</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#前言>前言</a></li><li><a href=#sync-mutex>sync.Mutex</a></li><li><a href=#sync-rwmutex>sync.RWMutex</a></li><li><a href=#sync-waitgroup>sync.WaitGroup</a></li><li><a href=#sync-map>sync.Map</a></li><li><a href=#sync-pool>sync.Pool</a></li><li><a href=#sync-once>sync.Once</a></li><li><a href=#sync-cond>sync.Cond</a></li></ul></li></ul></nav></div></div><div class=post-content><p>並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 <code>goroutine</code> 在訪問同一片內存時不會出現混亂的問題。</p><p><code>Go</code> 語言的 <code>sync</code> 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 <code>sync</code> 包裡這些同步的應用場景 ， 同時也會介紹 <code>sync</code> 包中的 <code>Pool</code> 和 <code>Map</code> 的應用場景和使用方法。</p><h2 id=前言>前言</h2><p>並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 <code>goroutine</code> 在訪問同一片內存時不會出現混亂的問題。</p><p><code>Go</code> 語言的 <code>sync</code> 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 <code>sync</code> 包裡這些同步的應用場景 ， 同時也會介紹 <code>sync</code> 包中的 <code>Pool</code> 和 <code>Map</code> 的應用場景和使用方法。</p><h2 id=sync-mutex>sync.Mutex</h2><p><code>sync.Mutex</code> 可能是 <code>sync</code> 包中最常使用的 。 它允許在共享資源上互斥訪問 ( 不能同時訪問 ) :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>mutex</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=p>{}</span>

<span class=nx>mutex</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
<span class=c1>// Update 共享變數(比如切片，結構體指針等)
</span><span class=c1></span><span class=nx>mutex</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>要注意的是，在第一次被使用後，不能再對 <code>sync.Mutex</code> 進行複製 。 ( sync 包的所有函式都一樣 ) 。</p><p>如果結構體具有同步程式字段，則必須通過指針傳遞它。</p><h2 id=sync-rwmutex>sync.RWMutex</h2><p><code>sync.RWMutex</code> 是一個讀寫互斥鎖 ， 它提供了我們上面的剛剛看到的 <code>sync.Mutex</code> 的 <code>Lock</code> 和 <code>UnLock</code> 方法（因為這兩個結構都實現了 <code>sync.Locker</code> 接口）。</p><p>但是，它還允許使用 <code>RLock</code> 和 <code>RUnlock</code> 方法進行並發讀取：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></pre></td><td class=lntd><pre class=chroma>mutex := &amp;sync.RWMutex{}

mutex.Lock()
// Update 共享變數
mutex.Unlock()

mutex.RLock()
// Read 共享變數
mutex.RUnlock()</pre></td></tr></table></div></div><p><code>sync.RWMutex</code> 允許至少一個讀鎖或一個寫鎖存在，而 <code>sync.Mutex</code> 允許一個讀鎖或一個寫鎖存在。</p><p>通過基準測試來比較這幾個方法的性能：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>BenchmarkMutexLock-4       <span class=m>83497579</span>         <span class=m>17</span>.7 ns/op
BenchmarkRWMutexLock-4     <span class=m>35286374</span>         <span class=m>44</span>.3 ns/op
BenchmarkRWMutexRLock-4    <span class=m>89403342</span>         <span class=m>15</span>.3 ns/op</code></pre></td></tr></table></div></div><p>可以看到鎖定/解鎖 <code>sync.RWMutex</code> 讀鎖的速度比鎖定/解鎖 <code>sync.Mutex</code> 更快，另一方面，在 <code>sync.RWMutex</code> 上調用 Lock()/ Unlock() 是最慢的操作。</p><p>因此，只有在頻繁讀取和不頻繁寫入的場景裡，才應該使用 <code>sync.RWMutex</code>。</p><h2 id=sync-waitgroup>sync.WaitGroup</h2><p><code>sync.WaitGroup</code> 也是一個經常會用到的函式，它的使用場景是在一個 <code>goroutine</code> 等待一組 <code>goroutine</code> 執行完成。</p><p><code>sync.WaitGroup</code> 擁有一個內部計數器 。 當計數器等於 0 時，則 <code>Wait()</code> 方法會立即返回 。 否則它將阻塞執行 <code>Wait()</code> 方法的 <code>goroutine</code> 直到計數器等於 0 時為止。</p><p>要增加計數器，我們必須使用 <code>Add(int)</code> 方法 。 要減少它 ， 我們可以使用 <code>Done()</code>（ 將計數器減 1 ），也可以傳遞負數給 <code>Add</code> 方法把計數器減少指定大小 ， <code>Done()</code> 方法底層就是通過 <code>Add(-1)</code>實現的。</p><p>在以下範例中，我們將啟動八個 <code>goroutine</code>，並等待他們完成：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>wg</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>{}</span>

<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
  <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
  <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Do something
</span><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
  <span class=p>}()</span>
<span class=p>}</span>

<span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
<span class=o>//</span> <span class=nx>blabla</span><span class=o>...</span></code></pre></td></tr></table></div></div><p>每次創建 <code>goroutine</code> 時，我們都會使用 <code>wg.Add(1)</code> 來增加 <code>wg</code> 的內部計數器。</p><p>我們也可以在 for 循環之前調用 <code>wg.Add(8)</code>。</p><p>與此同時 ， 每個 <code>goroutine</code> 完成時 ， 都會使用 <code>wg.Done()</code> 減少 <code>wg</code> 的內部計數器。</p><p><code>main goroutine</code> 會在八個 <code>goroutine</code> 都執行 <code>wg.Done()</code> 將計數器變為 <code>0</code> 後才能繼續執行。</p><h2 id=sync-map>sync.Map</h2><p><code>sync.Map</code> 是一個並發版本的 <code>Go</code> 的 <code>map</code> ， 我們可以 :</p><ul><li><p>使用 <code>Store(interface {}，interface {})</code> 增加元素。</p></li><li><p>使用 <code>Load(interface {}) interface {}</code> 檢索元素。</p></li><li><p>使用 <code>Delete(interface {})</code> 刪除元素。</p></li><li><p>使用 <code>LoadOrStore(interface {}，interface {}) (interface {}，bool)</code> 檢索或添加之前不存在的元素 。</p></li></ul><p>如果 <code>key</code> 之前在 <code>map</code> 中存在，則返回 <code>true</code>。</p><ul><li><p>使用 <code>Range</code> 遍歷元素。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>m</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Map</span><span class=p>{}</span>

<span class=c1>// 增加元素
</span><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=s>&#34;one&#34;</span><span class=p>)</span>
<span class=nx>m</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=s>&#34;two&#34;</span><span class=p>)</span>

<span class=c1>// 獲取元素1
</span><span class=c1></span><span class=nx>value</span><span class=p>,</span> <span class=nx>contains</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=k>if</span> <span class=nx>contains</span> <span class=p>{</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>.(</span><span class=kt>string</span><span class=p>))</span>
<span class=p>}</span>

<span class=c1>// 返回已存 value ， 否則把指定的鍵值儲存到 map 中
</span><span class=c1></span><span class=nx>value</span><span class=p>,</span> <span class=nx>loaded</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>.</span><span class=nf>LoadOrStore</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=s>&#34;three&#34;</span><span class=p>)</span>
<span class=k>if</span> <span class=p>!</span><span class=nx>loaded</span> <span class=p>{</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>.(</span><span class=kt>string</span><span class=p>))</span>
<span class=p>}</span>

<span class=nx>m</span><span class=p>.</span><span class=nf>Delete</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>

<span class=c1>// 遍歷所有元素
</span><span class=c1></span><span class=nx>m</span><span class=p>.</span><span class=nf>Range</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=nx>key</span><span class=p>,</span> <span class=nx>value</span> <span class=kd>interface</span><span class=p>{})</span> <span class=kt>bool</span> <span class=p>{</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d: %s\n&#34;</span><span class=p>,</span> <span class=nx>key</span><span class=p>.(</span><span class=kt>int</span><span class=p>),</span> <span class=nx>value</span><span class=p>.(</span><span class=kt>string</span><span class=p>))</span>
<span class=k>return</span> <span class=kc>true</span>
<span class=p>})</span></code></pre></td></tr></table></div></div></li></ul><p>上面會輸出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell>one
three
<span class=m>1</span>: one
<span class=m>2</span>: two</code></pre></td></tr></table></div></div><p>如你所見 ， <code>Range</code> 方法接收一個類型為<code>func(key，value interface {})bool</code> 的函式跟參數。</p><p>如果函數返回了 <code>false</code> ， 則停止迭迴。</p><p>有趣的是 ， 即使我們在一定的時間後返回 <code>false</code> ， 最壞情況下的時間複雜度仍為 <code>O(n)</code>。</p><p>我們應該在什麼時候使用 <code>sync.Map</code> 而不是在普通的 map 上使用 <code>sync.Mutex</code>？</p><ul><li><p>當我們對 map 有頻繁的讀取和不頻繁的寫入時。</p></li><li><p>當多個 <code>goroutine</code> 讀取，寫入和覆蓋不相交的 <code>key</code> 時。</p></li></ul><p>這是什麼意思呢 ？</p><p>例如 ， 如果我們有一個分片實現 ， 其中包含一組 4 個 <code>goroutine</code>，每個 <code>goroutine</code> 負責 25％ 的鍵（每個負責的鍵不衝突）。</p><p>在這種情況下，<code>sync.Map</code> 是首選。</p><h2 id=sync-pool>sync.Pool</h2><p>sync.Pool 是一個並發池 ， 負責安全地保存一組對象 。</p><p>它有兩個導出方法：</p><ul><li><p><code>Get() interface{}</code> 用來從並發池中取出元素。</p></li><li><p><code>Put(interface{})</code> 將一個對象加入並發池。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>pool</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>{}</span>

<span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nf>NewConnection</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
<span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nf>NewConnection</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
<span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nf>NewConnection</span><span class=p>(</span><span class=mi>3</span><span class=p>))</span>

<span class=nx>connection</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
<span class=nx>connection</span> <span class=p>=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span>
<span class=nx>connection</span> <span class=p>=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>connection</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span></code></pre></td></tr></table></div></div></li></ul><p>输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-shell data-lang=shell><span class=m>1</span>
<span class=m>3</span>
<span class=m>2</span></code></pre></td></tr></table></div></div><p>需要注意的是 Get()方法会从并发池中随机取出对象，无法保证以固定的顺序获取并发池中存储的对象。</p><p>還可以為 sync.Pool 指定一個創建者方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>pool</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>{</span>
  <span class=nx>New</span><span class=p>:</span> <span class=kd>func</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nf>NewConnection</span><span class=p>()</span>
  <span class=p>},</span>
<span class=p>}</span>

<span class=nx>connection</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>Connection</span><span class=p>)</span></code></pre></td></tr></table></div></div><p>每次調用 <code>Get()</code> 時 ， 將返回由在 <code>pool.New</code> 中指定的函數創建的對象（在本例中為指針）。</p><p>那麼什麼時候使用 <code>sync.Pool</code>？</p><p>有兩個使用案例：</p><p>第一個是當我們必須重用共享的和長期存在的對象（例如，數據庫連接）時。</p><p>第二個是用於優化內存分配。</p><p>讓我們考慮一個寫入緩衝區並將結果持久保存到文件中的函數示例。</p><p>使用 <code>sync.Pool</code> ，我們可以通過在不同的函數調用之間重用同一對象來重用為緩衝區分配的空間。</p><p>第一步是檢索先前分配的緩衝區（如果是第一個調用，則創建一個緩衝區，但這是抽象的）。</p><p>然後，<code>defer</code> 操作是將緩衝區放回 <code>sync.Pool</code>中。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>writeFile</span><span class=p>(</span><span class=nx>pool</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Pool</span><span class=p>,</span> <span class=nx>filename</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
    <span class=nx>buf</span> <span class=o>:=</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Get</span><span class=p>().(</span><span class=o>*</span><span class=nx>bytes</span><span class=p>.</span><span class=nx>Buffer</span><span class=p>)</span>

    <span class=k>defer</span> <span class=nx>pool</span><span class=p>.</span><span class=nf>Put</span><span class=p>(</span><span class=nx>buf</span><span class=p>)</span>

    <span class=c1>// Reset 緩存區，不然會連接上次調用時保存在緩存區裡的字符串foo
</span><span class=c1></span>    <span class=c1>// 編程foofoo 以此類推
</span><span class=c1></span>    <span class=nx>buf</span><span class=p>.</span><span class=nf>Reset</span><span class=p>()</span>

    <span class=nx>buf</span><span class=p>.</span><span class=nf>WriteString</span><span class=p>(</span><span class=s>&#34;foo&#34;</span><span class=p>)</span>
    <span class=k>return</span> <span class=nx>ioutil</span><span class=p>.</span><span class=nf>WriteFile</span><span class=p>(</span><span class=nx>filename</span><span class=p>,</span> <span class=nx>buf</span><span class=p>.</span><span class=nf>Bytes</span><span class=p>(),</span> <span class=mo>0644</span><span class=p>)</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><h2 id=sync-once>sync.Once</h2><p>sync.Once 是一個簡單而強大的函式，可確保一個函數僅執行一次。</p><p>在下面的示例中，只有一個 goroutine 會顯示輸出消息：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>once</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span><span class=p>{}</span>
<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>i</span>
    <span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
        <span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;first %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
        <span class=p>})</span>
    <span class=p>}()</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>我們使用了 Do(func())方法來指定只能被調用一次的部分。</p><h2 id=sync-cond>sync.Cond</h2><p><code>sync.Cond</code> 可能是 <code>sync</code> 包提供的函式中最不常用的一個 ， 它用於發出信號（一對一）或廣播信號（一對多）到 <code>goroutine</code>。</p><p>讓我們考慮一個場景，我們必須向一個 <code>goroutine</code> 指示共享切片的第一個元素已更新 。</p><p>創建 <code>sync.Cond</code> 需要 <code>sync.Locker</code> 對象（<code>sync.Mutex</code> 或 <code>sync.RWMutex</code>）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><span class=lnt>1
</span></pre></td><td class=lntd><pre class=chroma>cond := sync.NewCond(&amp;sync.Mutex{})</pre></td></tr></table></div></div><p>然後，讓我們編寫負責顯示切片的第一個元素的函數：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>printFirstElement</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>cond</span> <span class=err>\</span><span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Cond</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
    <span class=nx>cond</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
    <span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
<span class=p>}</span></code></pre></td></tr></table></div></div><p>我們可以使用 <code>cond.L</code> 訪問內部的互斥鎖。</p><p>一旦獲得了鎖，我們將調用 <code>cond.Wait()</code> ， 這會讓當前 <code>goroutine</code> 在收到信號前一直處於阻塞狀態 。</p><p>讓我們回到 <code>main goroutine</code>。</p><p>我們將通過傳遞共享切片和先前創建的 <code>sync.Cond</code> 來創建 <code>printFirstElement</code> 池 。</p><p>然後我們調用 <code>get()</code> 函數，將結果存儲在 <code>s[0]</code> 中並發出信號：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>s</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>runtime</span><span class=p>.</span><span class=nf>NumCPU</span><span class=p>();</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
    <span class=nx>o</span> <span class=nf>printFirstElement</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=nx>cond</span><span class=p>)</span>
<span class=p>}</span>

<span class=nx>i</span> <span class=o>:=</span> <span class=nf>get</span><span class=p>()</span>
<span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
<span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
<span class=nx>cond</span><span class=p>.</span><span class=nf>Signal</span><span class=p>()</span>
<span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>這個信號會解除一個 <code>goroutine</code> 的阻塞狀態 ， 解除阻塞的 <code>goroutine</code> 將會顯示 s[0]中存儲的值 。</p><p>但是，有的人可能會爭辯說我們的代碼破壞了 <code>Go</code> 的最基本原則之一：</p><blockquote><p>不要通过共享内存进行通信；而是通过通信共享内存。</p></blockquote><p>確實 ， 在這個示例中，最好使用 <code>channel</code> 來傳遞 <code>get()</code> 返回的值 。</p><p>但是我們也提到了 <code>sync.Cond</code> 也可以用於廣播信號 。</p><p>我們修改一下上面的示例，把 <code>Signal()</code> 調用改為調用 <code>Broadcast()</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-go data-lang=go><span class=nx>i</span> <span class=o>:=</span> <span class=nf>get</span><span class=p>()</span>
<span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
<span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=nx>i</span>
<span class=nx>cond</span><span class=p>.</span><span class=nf>Broadcast</span><span class=p>()</span>
<span class=nx>cond</span><span class=p>.</span><span class=nx>L</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span></code></pre></td></tr></table></div></div><p>這種情況下，所有 <code>goroutine</code> 都將被觸發。</p><p>眾所周知，channel 裡的元素只會由一個 <code>goroutine</code>接收到。通過 <code>channel</code> 模擬廣播的唯一方法是關閉 <code>channel</code>。</p><p>當一個 <code>channel</code> 被關閉後 ， <code>channel</code> 中已經發送的數據都被成功接收後 ， 後續的接收操作將不再阻塞 ， 它們會立即返回一個零值 。</p><p>但是這種方式只能廣播一次。因此，儘管存在很大爭議，但這無疑是 <code>sync.Cond</code> 的一個有趣的功能 。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Feng-Chi</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2020-07-07</span></p><p class=copyright-item><span class=item-title>許可協議</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/golang/>golang</a></div><nav class=post-nav><a class=prev href=/post/2020/07/go-goruutine-channel/><i class="iconfont icon-left"></i><span class="prev-text nav-default">Goroutine 和 Channel 講解</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/2020/07/blog-build-process/><span class="next-text nav-default">本站建置過程紀錄</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=comments-gitment></div><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js crossorigin=anonymous></script><script type=text/javascript>var gitment=new Gitment({id:'2020-07-07 15:07:16 \x2b0800 \x2b0800',title:'Go 語言 sync 包的應用詳解',link:decodeURI(location.href),desc:'\x3cp\x3e並發程式中的同步也就是我們通常說的鎖的主要作用是保證多個線程或者 \x3ccode\x3egoroutine\x3c\/code\x3e 在訪問同一片內存時不會出現混亂的問題。\x3c\/p\x3e\n\n\x3cp\x3e\x3ccode\x3eGo\x3c\/code\x3e 語言的 \x3ccode\x3esync\x3c\/code\x3e 包提供了常見的並發程式同步 。 今天的文章裡讓我們回到應用層 ， 聚焦 \x3ccode\x3esync\x3c\/code\x3e 包裡這些同步的應用場景 ， 同時也會介紹 \x3ccode\x3esync\x3c\/code\x3e 包中的 \x3ccode\x3ePool\x3c\/code\x3e 和 \x3ccode\x3eMap\x3c\/code\x3e 的應用場景和使用方法。\x3c\/p\x3e',owner:'holmeslin',repo:'holmeslin.github.io',oauth:{client_id:'05f414719d56905a1d49',client_secret:'7d76251defef60a6cc6aa55627c7c2f51b7429b0'}});gitment.render('comments-gitment');</script><noscript>Please enable JavaScript to view the <a href=https://github.com/imsun/gitment>comments powered by gitment.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:holmes.lin@gmail.com class="iconfont icon-email" title=email></a><a href=https://facebook.com/fengchilin class="iconfont icon-facebook" title=facebook></a><a href=https://www.linkedin.com/in/holmeslin/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/holmeslin class="iconfont icon-github" title=github></a><a href=https://holmeslin.github.io/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2019 -
2020
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Feng-Chi</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.d7b7ada643c9c1a983026e177f141f7363b4640d619caf01d8831a6718cd44ea.js></script></body></html>